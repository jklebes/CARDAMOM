
###
## function to return x,y coordinate from an array which is nearest to a provided lat / long value
###

# This function is based on an original Matlab function development by A. A. Bloom (UoE, now at the Jet Propulsion Laboratory).
# Translation to R and subsequent modifications by T. L Smallman (t.l.smallman@ed.ac.uk, UoE).

closest2d <- function (id,lat,long,lat_in,long_in,nos_dim) {

    # extract needed lat / long
    lat1 = lat_in[id] ; long1 = long_in[id]
    # calculate the distance between two points by Spherical law of the cosine
    # mean radius of earth in km
    R = 6371  # 6378137 m (R source equitorial)
    # convert degrees to radians
    deg_to_rad = 0.01745329 #pi/180
    # check lat long system
    if (length(which(as.vector(long) > 180)) > 1) {stop("Input error closest2d: longitude should be -180 to +180")}

    if (nos_dim == 1) {
      	## lat long are in single vectors repeating i.e. lat[1:10]=89.9,89.9,89.9... ; long[1:10]=-180,-160,-140....
      	# loop through to find the smallest distance
      	d_old = 1e6
      	# check for locations which exactly coincide, complete calculation and finally remove NaN generated by value "1"
      	d = acos(sin(lat1*deg_to_rad)*sin(lat*deg_to_rad)+cos(lat1*deg_to_rad)*cos(lat*deg_to_rad)*cos((long*deg_to_rad)-(long1*deg_to_rad)))*R
      	match = which(is.na(d) == TRUE)
        d[match] = 0
      	output=which(d == min(d))[1] ; d_old=d[output]
      	if (d_old > 10) {print(paste("id = ",id," Minimum distance found (",round(d_old,digits=1),") is greater than 10 km from actual location"))}
      	rm(d_old)
    } else if (nos_dim == 2) {
      	## lat and long are in two - dimensional arrays which co-varying
      	# loop through to find the smallest distance
      	d = sin(lat1*deg_to_rad)*sin(as.vector(lat)*deg_to_rad)+cos(lat1*deg_to_rad)*cos(as.vector(lat)*deg_to_rad)*cos((as.vector(long)*deg_to_rad)-(long1*deg_to_rad))
      	# check for locations which exactly coincide, complete calculation and finally remove NaN generated by value "1"
        d = acos(d)*R ; match = which(is.na(d) == TRUE) ; d[match] = 0 #; print(match)
      	if (min(d) > 10) {print(paste("id = ",id," Minimum distance found (",round(min(d),digits=1),") is greater than 10 km from actual location"))}
        # Track location of the minimum distance
        d_loc = which(d == min(d))
        # Determine the i dimension location.
        # Ceiling forces rounding up before numerically secure minus 1 to keep things in bound at either end
        i = d_loc - (  (ceiling(d_loc/dim(lat)[1]) - 1) * dim(lat)[1] )
        # Determine the j dimension
        j = ceiling(d_loc / dim(lat)[1])
        # Prepare output and tidy
      	output = list(i[1],j[1]) ; rm(i,j)
    } else if (nos_dim == 3) {
      	## lat and long are in two 1-dimensional vectors but co-varying as in cartesian co-ordinates
      	# loop through to find the smallest distance
      	d_old=1e6
      	for (j in seq(1, length(lat))) {
      	    # convert all to radians
      	    d = acos(sin(lat1*deg_to_rad)*sin(lat[j]*deg_to_rad)+cos(lat1*deg_to_rad)*cos(lat[j]*deg_to_rad)*cos((long*deg_to_rad)-(long1*deg_to_rad)))*R
            if (is.na(min(d))) {d[is.na(d)] = 0}
      	    if (min(d) < d_old) {
            	possible_i = which(d == min(d))
            	if (length(possible_i) > 1 & possible_i[1] == 1 & possible_i[length(possible_i)] == length(long)) {
            	    possible_i = possible_i[which(long[possible_i] == long1)]
            	}
            	output = list(possible_i[1],j) ; d_old=min(d)
      	    } # min(d) < d_old
      	} # j loop
      	if (d_old > 10) {print(paste("id = ",id," Minimum distance found (",round(d_old,digits=1),") is greater than 10 km from actual location"))}
      	rm(d_old)

    } # grid type

    # clean up
    rm(d,R,lat1,long1) # ; gc() ; gc()
    # return to the user
    return(output)

} # end of function

## Use byte compile
closest2d<-cmpfun(closest2d)
